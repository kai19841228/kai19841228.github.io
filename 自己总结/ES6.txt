let obj = {}                  object es6属性        http://www.softwhy.com/article-9057-1.html 
Object.keys(obj) // 返回obj的所有key值
Object.values(obj) // 返回obj的所有值
Object.entries(obj) // 把obj的键值 转成数组
Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组  https://www.jianshu.com/p/6f4537bb89b2
Object.getOwnPropertyNames(antzone)  获取对象的属性名称并存储在数组中。返回值是存放属性名称的数组。特别说明：必须是自有属性，自有属性就是非原型链继承的属性。http://www.softwhy.com/article-9090-1.html
Object.defineProperty(obj, prop, desc)  Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性


var arr = ['a', 'b', 'c', 'd'];
for in 循环取出的是键名
for (let a in arr) {
  console.log(a); // 0 1 2 3
}
for of 循环取出的是键值
for (let a of arr) {
  console.log(a); // a b c d
}

ES6 async await

function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  let foo = await fetch('https://api.example.com');
  let bar = await fetch('https://api.example.com');
  console.log(value);
}

asyncPrint('hello world', 50);

ES6  let const
let和const 都是局部变量，只有在当前的代码块才能获取到 
ES6  obj结构
     let obj = {a:’1’,b:’2’,c:’3’}
     let {a,c} = obj  //把obj里的变量函数结构
ES6  proxy 代理
let data = {
	name: '789',
	age: 20,
	score: 59
}
var obj = new Proxy(data, {
	get: function (target, key, receiver) {
		console.log(`getting ${key}!`);
		if (key in target) {
			// return target[key]; // 直接返回 key 对应的 value
			return Reflect.get(target, key, receiver);
		} else {
			throw new ReferenceError("Property \"" + key + "\" does not exist.");
		}
	},
	set: function (target, key, value, receiver) {
		console.log(`setting ${key}!`);
		// throw new Error('服务类型只读') // 如果属性不能修改就抛出异常
		if (key === 'age') { // 设置age属性是，必须是小于200的数字。
			if (!Number.isInteger(value)) {
				throw new TypeError('The age is not an integer');
			}
			if (value > 200) {
				throw new RangeError('The age seems invalid');
			}
		}
		// return target[key]=value // set key的新值
		return Reflect.set(target, key, value, receiver);
	},
	apply (target, ctx, args) { // 函数为target时，会被apply方法拦截。
		return Reflect.apply(...arguments) * 2;
	},
	has(target, prop) { // 是否包含这个属性，会被has 拦截。
		if (prop === 'score' && target[prop] < 60) {
		console.log(`${target.name} 不及格`);
		// return false;
		}
		return prop in target;
  	}
});
console.log(obj.age)
setTimeout(() => {
	obj.name = "申伟杰"
	console.log(obj.name)
	console.log('score' in obj)
}, 1000);

ES6 promise 
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}
loadImageAsync('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png?qua=high&where=super').then((data)=>{
console.log(data.src)
}).catch(error => {・・・})
.finally(() => {・・・});
promise
.then(result => {・・・})   // 成功回调
.catch(error => {・・・})   // 失败回调
.finally(() => {・・・});   // 不管成功失败都会执行

const p = Promise.all([p1, p2, p3])  Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});

Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。   多个promise实例那个先返回就用那个promise的实例返回

Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。

const jsPromise = Promise.resolve($.ajax('/whatever.json'));    有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。

