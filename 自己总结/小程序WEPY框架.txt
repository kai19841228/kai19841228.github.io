https://www.jianshu.com/p/c34a7cc08fc8  参考网址
https://www.jianshu.com/p/e30436ba773f  参考网址
sudo npm install wepy-cli -g   安装wepy
wepy init standard myproject   新建项目 myproject是你的项目名称
cd myproject                   进入项目文件夹
npm  install                   安装依赖
wepy build --watch=npm run dev 开启实时编译

原wx的属性方法，都挂在wepy下了。可以直接调用

wepy.navigateTo({url: '../lineOrder/index'})
wepy.redirectTo({url: '../lineOrder/index'})
wepy.navigateBack()

this.$wxpage     获取的是当前page对象
this.$parent     获取到根 上的globalData

1 let self = this
self.$apply()      触发wepy框架的脏检查，更新view层的数据。method里面的方法是不用这个的，但methods里面只能放bindtap这类方法，所以你自己定义的其他方法，或者写在onshow里面，就必须得用this.$apply()。
1.1 wepy 数据绑定
  this.title = 'this is title';
1.2 wepy 优化事件参数传递 wepy 建议传参方式
  <view bindtap="tapName({{index}}, 'wepy', 'otherparams')"> Click me! </view>
  methods: {
    tapName (id, title, other, event) {
        console.log(id, title, other)// output: 1, wepy, otherparams
    }
  }
1.3 this.$parent.globalData.aa   调用app。wepy里的全局数据。在其他page也调用
    在Page页面实例中，可以通过this.$parent来访问App实例。
    wepy.$instance.globalData.aa 获取wepy全局数据
2 wepy.component基类提供三个方法$broadcast，$emit，$invoke，
  $broadcast事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。
  $emit由某个子组件发起，其所有祖先组件会依次接收到$emit事件。
  $invoke是一个页面或组件，直接调用另一个组件的方法。通过传入组件路径找到相应的组件，然后再调用其方法。
3 静态传值 使用静态传值时，子组件会接收到字符串的值。
  <child title="mytitle"></child>
4 动态传值 动态传值是指父组件向子组件传递动态数据内容，父子组件数据完全独立互不干扰。但可以通过使用.sync修饰符来达到父组件数据绑定至子组件的效果，也可以通过设置子组件props的twoWay: true来达到子组件数据绑定至父组件的效果。那如果即使用.sync修饰符，同时子组件props中添加的twoWay: true时，就可以实现数据的双向绑定了。
  // parent.wpy
  <child :title="parentTitle" :syncTitle.sync="parentTitle" :twoWayTitle="parentTitle"></child>
  data = {
    parentTitle: 'p-title'
  };
  // child.wpy
  props = {
    title: String,
    syncTitle: {
        type: String,
        default: 'null'
    },
    twoWayTitle: {
        type: Number,
        default: 50,
        twoWay: true
    }
  }
  onLoad () {
    console.log(this.title); // p-title
    console.log(this.syncTitle); // p-title
    console.log(this.twoWayTitle); // 50

    this.title = 'c-title';
    console.log(this.$parent.parentTitle); // p-title.
    this.twoWayTitle = 60;
    console.log(this.$parent.parentTitle); // 60.  --- twoWay为true时，子组件props修改会改变父组件对应的值
    this.$parent.parentTitle = 'p-title-changed';
    console.log(this.title); // 'p-title';
    console.log(this.syncTitle); // 'p-title-changed' --- 有sync属性的props，当父组件改变时，会影响子组件的值。
  }
5 组件自定义事件 目前有三种后缀： <child @childFn.user="parentFn"></child>
  .default: 绑定小程序冒泡事件事件，如bindtap。
  .stop: 绑定小程序非冒泡事件，如catchtap。
  .user: 绑定用户自定义组件事件，通过``$emit`触发
  // index.wpy
  <template>
    <child @childFn.user="parentFn"></child>
  </template>
  <script>
    import wepy from 'wepy';
    import Child from './coms/child';
    export default class Index extends wepy.page {
        components = {
            child: Child
        };

        methods = {
            parentFn (num, evt) {
                console.log('parent received emit event, number is: ' + num)
            }
        }
    }
  </script>


  // child.wpy
  <template>
    <view @tap="tap">Click me</view>
  </template>
  <script>
    import wepy from 'wepy';
    export default class Child extends wepy.component {
        methods = {
            tap () {
                console.log('child is clicked');
                this.$emit('childFn', 100);
            }
        }
    }
  </script>
6 组件代替模板和模块
  <!-- /components/item.wpy -->
  <text>{{text}}</text>

  <!-- index.wpy -->
  <template>
    <component id="item"></component>
  </template>
  <script>
    import wepy from 'wepy';
    import Item from '../components/item';
    export default class Index extends wepy.page {
        components = { Item }
    }
  </script>